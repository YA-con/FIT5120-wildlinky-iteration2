# -*- coding: utf-8 -*-
"""Final_Prediction_viz.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15GlHbTyyeeoMIC8d5ZqMIBWwN3AmHn1Q
"""

import pandas as pd
import numpy as np
import plotly.graph_objects as go
from sklearn.linear_model import LinearRegression
from sklearn.impute import SimpleImputer
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import GridSearchCV, cross_val_score
from sklearn.metrics import mean_squared_error

# Load data
df = pd.read_csv("prediction_dataset.csv")
features = ['urban_area_ha', 'burned_area_ha', 'rainfall_annual_mm', 'temp_annual_c', 'population']
target = 'species_count'
df_filled = df.copy()

# Impute missing values with LR per feature
for feature in features:
    if df_filled[feature].isnull().sum() > 0:
        other_features = [f for f in features if f != feature]
        train = df_filled[df_filled[feature].notna()]
        test = df_filled[df_filled[feature].isna()]
        if not test.empty:
            imputer = SimpleImputer(strategy='mean')
            X_train = pd.DataFrame(imputer.fit_transform(train[other_features]), columns=other_features)
            y_train = train[feature]
            X_test = pd.DataFrame(imputer.transform(test[other_features]), columns=other_features)
            model = LinearRegression()
            model.fit(X_train, y_train)
            df_filled.loc[df_filled[feature].isna(), feature] = model.predict(X_test)

# Fallback imputation for target
if df_filled[target].isnull().sum() > 0:
    df_filled[target] = SimpleImputer(strategy='mean').fit_transform(df_filled[[target]])

# Train optimized Random Forest
X = df_filled[features]
y = df_filled[target]
rf = RandomForestRegressor(random_state=42)
param_grid = {
    'n_estimators': [200],
    'max_depth': [5, 10, None],
    'min_samples_split': [2, 5],
    'min_samples_leaf': [1, 2]
}
grid_search = GridSearchCV(rf, param_grid, scoring='neg_mean_squared_error', cv=5, n_jobs=-1)
grid_search.fit(X, y)
best_rf = grid_search.best_estimator_

# Evaluate errors
rmse_cv = np.mean(np.sqrt(-cross_val_score(best_rf, X, y, scoring='neg_mean_squared_error', cv=5)))

# Prepare actual data (until 2025)
initial_count = 232
past_df_trimmed = df_filled[df_filled['year'] <= 2025][['year', 'species_count']].copy()
past_df_trimmed['cumulative_species'] = past_df_trimmed['species_count'].cumsum() + initial_count
past_df_trimmed['lower'] = past_df_trimmed['cumulative_species']
past_df_trimmed['upper'] = past_df_trimmed['cumulative_species']
past_df_trimmed['type'] = 'Actual'

# Predict for future years
future_years = list(range(2026, 2101))
future_X = pd.DataFrame([X.mean()] * len(future_years))
future_preds = best_rf.predict(future_X)

future_df = pd.DataFrame({
    'year': future_years,
    'species_count': future_preds,
})
future_df['cumulative_species'] = future_df['species_count'].cumsum() + past_df_trimmed['cumulative_species'].iloc[-1]
future_df['lower'] = future_df['cumulative_species'] - rmse_cv
future_df['upper'] = future_df['cumulative_species'] + rmse_cv
future_df['type'] = 'Predicted'

# Get cutoff year where cumulative reaches 1000
cutoff_year = future_df[future_df['cumulative_species'] >= 1000]['year'].min()
highlight_y = 1000

future_trimmed = future_df[future_df['year'] <= cutoff_year]
combined_df = pd.concat([past_df_trimmed, future_trimmed], ignore_index=True)

# Create plot
fig = go.Figure()

# Actual line
fig.add_trace(go.Scatter(
    x=combined_df[combined_df['type'] == 'Actual']['year'],
    y=combined_df[combined_df['type'] == 'Actual']['cumulative_species'],
    mode='lines+markers',
    name='Actual Species Listings (2001â€“2025)',
    line=dict(color='#07431E', width=3),
    marker=dict(size=6, symbol='circle'),
    hovertemplate='Year: %{x}<br>Actual Cumulative: %{y:.0f} species'
))

# Predicted line
fig.add_trace(go.Scatter(
    x=combined_df[combined_df['type'] == 'Predicted']['year'],
    y=combined_df[combined_df['type'] == 'Predicted']['cumulative_species'],
    mode='lines+markers',
    name='Projected Listings (2026+)',
    line=dict(color='#B32525', dash='dash', width=3),
    marker=dict(size=6, symbol='diamond'),
    hovertemplate='Year: %{x}<br>Predicted Cumulative: %{y:.0f} species'
))

# Error band
fig.add_trace(go.Scatter(
    x=pd.concat([
        combined_df[combined_df['type'] == 'Predicted']['year'],
        combined_df[combined_df['type'] == 'Predicted']['year'][::-1]
    ]),
    y=pd.concat([
        combined_df[combined_df['type'] == 'Predicted']['upper'],
        combined_df[combined_df['type'] == 'Predicted']['lower'][::-1]
    ]),
    fill='toself',
    fillcolor='rgba(179, 37, 37, 0.2)',
    line=dict(color='rgba(255,255,255,0)'),
    hoverinfo="skip",
    name=f'Â±{rmse_cv:.2f} species error'
))

# Horizontal line at 1000
fig.add_shape(
    type="line",
    x0=2001, x1=2100,
    y0=1000, y1=1000,
    line=dict(color="black", width=2, dash="dot"),
    name="1000 Species Threshold"
)

# Vertical highlight line at cutoff year
fig.add_shape(
    type="line",
    x0=cutoff_year, x1=cutoff_year,
    y0=0, y1=highlight_y,
    line=dict(color="red", width=2, dash="dot")
)

# Annotation on year
fig.add_annotation(
    x=cutoff_year,
    y=highlight_y,
    text=f"<b>{cutoff_year}: 1000 Species Threatened</b>",
    showarrow=True,
    arrowhead=2,
    ax=0,
    ay=-80,
    font=dict(size=14, color="red")
)

# Layout
fig.update_layout(
    #title="ðŸš¨ Projected Growth of Threatened Species in Victoria",
    xaxis=dict(
        title="Year",
        range=[2000, cutoff_year + 2]  # Trim excess years
    ),
    # xaxis_title="Year",
    yaxis_title="Cumulative Species Listed as Threatened",
    template='plotly_white',
    font=dict(family="Instrument Sans, sans-serif", size=14),
    hovermode='x unified',
    margin=dict(l=40, r=40, t=60, b=40),
    legend=dict(x=0.01, y=0.99, bgcolor='rgba(255,255,255,0.7)')
)

# Export to HTML
fig.write_html("final_rf_projection_1000_impactful.html")